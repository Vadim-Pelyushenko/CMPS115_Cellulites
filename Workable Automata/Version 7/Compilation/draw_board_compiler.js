// Here is a simple compilation that just wraps the user's code input for drawing
// it just turns their code into a function, and also gives them reference for
// ctx, cellWidth, grid
function compileCoarseDrawing(rawCode)
{
    let result = "";

    result += "// This function has been generated by wrapping the user's code\n";
    result += "// the user's original code is marked with 2 comments, and has been\n";
    result += "// indented by one level(as the function wraps it).\n";
    result += portion_1();

    let lines = rawCode.split("\n");

    result += "\t// THE FOLLOWING IS THE RAW INPUT OF THE USER\n";
    // indent everything by one more level
    for(let i = 0; i < lines.length; i++)
        result += "\t" + lines[i] + "\n";

    result += "\t// THE PRECEDING IS THE RAW INPUT OF THE USER\n";

    result += "}\n";


    return result;
}


// Below lies compilation of code that calculates color and saves it as an integer
// with the identifier compute_color
// ---------------------------------------------------------------------------------------------
//
function compileComputedColor(rawCode)
{
    let result = "";

    let part1 = portion_1();
    let part2 = portion_2();
    let part3 = portion_3();
    let startComment = "\t\t\t// THE FOLLOWING IS THE RAW INPUT OF THE USER\n";
    let endComment   = "\t\t\t// THE PRECEDING IS THE RAW INPUT OF THE USER\n";

    result += "// This function has been generated by wrapping the user's code\n";
    result += "// it allows the user to compute the color through their own code\n";
    result += "// the result of their code(stored in the variable compute_color\n";
    result += "// is utilised shortly after\n";

    result += part1;
    result += part2;
    result += "\t\t\tlet compute_color = 0;\n\n";

    let lines = rawCode.split("\n");

    result += startComment;
    // indent everything by three more levels(function, then for loop, and another for loop)
    for(let i = 0; i < lines.length; i++)
        result += "\t\t\t" + lines[i] + "\n";
    result += endComment + "\n";

    result += "\t\t\tctx.fillStyle = \"#\" + (\"000000\" + compute_color.toString(16).toUpperCase()).slice(-6);\n";
    // result += "\t\t\tctx.fillStyle = \"#\" + compute_color.toString(16);\n";
    result += part3;

    return result;
}


// Below lies compilation of mapping code
// ---------------------------------------------------------------------------------------------
//
//https://www.w3schools.com/js/js_string_methods.asp
//https://stackoverflow.com/questions/6507056/replace-all-whitespace-characters
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split
//
//As of right now the user must specify all colors each time they input a color.
//
// NOTE: VALIDATION OF USER INPUT NEEDED
function compileMapping(rawCode)
{
    let part1 = portion_1();
    let part2 = portion_2();
    let part3 = portion_3();
    let startComment = "// THE FOLLOWING CODE HAS BEEN GENERATED FROM A MAPPING\n";
    let endComment   = "// THE PRECEDING CODE HAS BEEN GENERATED FROM A MAPPING\n";

    let compiledFunction = null;
    let index;
    let color0 = "";
    let color1 = "";

    //Lines is an array of the user input, with each line being a different element.
    let lines = rawCode.split("\n");	

    //Removes all whitespace
    for (let i = 0; i < lines.length; i++)
    {
        lines[i] = lines[i].replace(/\s/g, ""); //Deletes all of the white space in a given line
        lines[i] = lines[i].toUpperCase();

        if(lines[i].indexOf(">") == -1)
            lines.splice(i,1);
    }

    // Go through all the lines and collect states and colors
    let states = new Array(lines.length);
    let colors = new Array(lines.length);

    for(let i = 0; i < lines.length; i++)
    {
        let cutoff = lines[i].indexOf(">");
        states[i] = parseInt(lines[i].substring(0,cutoff-1));
        colors[i] = lines[i].substring(cutoff+1);
    }

    let conditionals = generateIfStatements(states,colors);

    return startComment + part1 + part2 + conditionals + part3 + endComment;
}

function generateIfStatements(states,colors)
{
    if(states.length == 0)
    {
        console.log("NO STATES HAVE BEEN PROVIDED");
        return null;
    }
    else if(states.length != colors.length)
    {
        console.log("NUMBER OF STATES AND NUMBER OF COLORS PROVIDED DIFFERS");
        return null;
    }

    let result = "";

    result += "\t\t\tif(state[0] == " + states[0] + ")\n";
    result += "\t\t\t{\n";
    result += "\t\t\t\tctx.fillStyle = \"" + colors[0] + "\";\n";
    result += "\t\t\t}\n";

    for(let k = 1; k < states.length; k++)
    {
        result += "\t\t\telse if(state[0] == " + states[k] + ")\n";
        result += "\t\t\t{\n";
        result += "\t\t\t\tctx.fillStyle = \"" + colors[k] + "\";\n";
        result += "\t\t\t}\n";
    }

    result += "\t\t\telse\n";
    result += "\t\t\t{\n";
    result += "\t\t\t\tctx.fillStyle = \"" + randomHexColor() + "\";\n";
    result += "\t\t\t}\n";

    return result;
}

//https://www.paulirish.com/2009/random-hex-color-code-snippets/
function randomHexColor()
{
    return '#' + ("000000" + Math.random().toString(16).slice(2, 8).toUpperCase()).slice(-6);
}

// Code structure that doesn't change
// -------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------


// The function header and convenient declarations
function portion_1()
{
    let part1 = "";

    part1 += "function()\n";
    part1 += "{\n";
    part1 += "\tlet ctx = this.context;\n";
    part1 += "\tlet cellWidth = this.cellWidth;\n";
    part1 += "\tlet grid = this.board.grid;\n\n";
    part1 += "\tlet zoom = this.zoom_controller;\n";
    part1 += "\tlet rowBegin = zoom.topRowBound;\n";
    part1 += "\tlet colBegin = zoom.leftColBound;\n";
    part1 += "\tlet rowEnd = Math.min(zoom.bottomRowBound,this.board.rows-1);\n";
    part1 += "\tlet colEnd = Math.min(zoom.rightColBound,this.board.cols-1);\n";
    part1 += ""; // RESUMING FIXING THIS SO THAT IT TAKES THE ZOOM INTO ACCOUNT

    return part1;
}

function portion_2()
{
    let part2 = "";

    part2 += "\tctx.fillStyle = \"#000000\";";
    part2 += "\tctx.fillRect(0, 0, this.canv.width, this.canv.height);\n\n";
    part2 += "\tfor(let r = rowBegin; r <= rowEnd; r++)\n";
    part2 += "\t{\n";
    part2 += "\t\tfor(let c = colBegin; c <= colEnd; c++)\n";
    part2 += "\t\t{\n";
    part2 += "\t\t\tlet state = grid[r][c].state;\n\n";

    return part2;
}

function portion_3()
{
    let part3 = "";

    part3 += "\t\t\tctx.fillRect(c*cellWidth, r*cellWidth, cellWidth, cellWidth);\n";
    part3 += "\t\t}\n";
    part3 += "\t}\n";
    part3 += "}\n";

    return part3;
}