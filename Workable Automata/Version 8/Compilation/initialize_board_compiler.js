// This parses through text that contains the literal values of each cell in a grid, and returns
// a grid of cells with the same states, along with the dataWidth of the cells.
//
// The grid must be formatted as 
// sets of curly braces containing each row of the grid,
// sets of square brackets in each row containing states of cells
// integers in square brackets that represent the state of a single cell.
// all of these things are comma separated. Rows are comma separated, states are comma separated,
// integers are comma separated 
//
// https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_match_regexp
// https://www.w3schools.com/jsref/jsref_regexp_g.asp
// https://regexr.com/43ock
function parseInitialization(rawData)
{
	let numRows = -1;
	let numCols = -1;
	let numData = -1;

	let rows = rawData.match(/{[^{}]*}/g);
	numRows = rows.length;
	let grid = new Array(numRows);

	for(let i = 0; i < numRows; i++)
	{
		let currRow = rows[i];
		currRow = currRow.substring(1,currRow.length-1);
		// console.log("ROW " + i + ": " + currRow);

		let cols = currRow.match(/\[[^\[\]]+\]/g);

		if(numCols == -1)
			numCols = cols.length;
		else if(cols.length != numCols)
		{
			let errorMessage = "";
			errorMessage += "INCONSISTENT NUMBER OF COLUMNS PER ROW\n";
			errorMessage += "row " + i + " has " + cols.length + "columns\n";
			errorMessage += "but all preceding rows have " + numCols + " columns\n";
			console.log(errorMessage);
			return null;
		}

		grid[i] = new Array(numCols);

		for(let j = 0; j < numCols; j++)
		{
			let currCol = cols[j];
			currCol = currCol.substring(1,currCol.length-1);
			// console.log("\tCOLUMN " + j + ": " + currCol);

			let data = currCol.match(/[+-]?[0-9]+/g);
			// console.log("\t\tData in row " + i + ", col " + j + ": " + data);

			if(numData == -1)
				numData = data.length;
			else if(data.length != numData)
			{
				let errorMessage = "";
				errorMessage += "INCONSISTENT NUMBER OF QUANTITY OF DATA PER CELL\n";
				errorMessage += "the cell at row: " + i + ", col: " + j;
				errorMessage += " has a dataWidth of " + data.length + "\n";
				errorMessage += "but all preceding cells have a dataWidth of " + numData;
				console.log(errorMessage);
				return null;
			}

			grid[i][j] = new Cell(this,numData,i,j);

			for(let k = 0; k < data.length; k++)
			{
				// console.log("\t\tdata[" + k + "]: " + data[k]);
				grid[i][j].setCurrentState(k,parseInt(data[k]));
				grid[i][j].setFutureState(k,parseInt(data[k]));
			}
		}
	}

	console.log("numRows: " + numRows);
	console.log("numCols: " + numCols);
	console.log("numData: " + numData);

	return grid;
}

// Below lies compilation of code that computes the initial state of each cell
//--------------------------------------------------------------------------------------------
// This will simply wrap the user's code and utilise is similar to how compileComputedColor
// works in draw_board_compiler
function compileInit(rawCode,dataWidth)
{
	let result = "";

	let head = initHeader();
	let end = initEnder();
	let startComment = "\t\t\t// THE FOLLOWING IS THE RAW INPUT OF THE USER\n";
	let endComment = "\t\t\t// THE PRECEDING IS THE RAW INPUT OF THE USER\n";
	let lines = rawCode.split("\n");

	result += "// This function has been generated by wrapping the user's code\n";
	result += "// it allows the user to initialize each cell base on it's row and column\n";

	result += initHeader(dataWidth);


	result += startComment;
	// indent everything by three more levels(function, then for loop, and another for loop)
	for(let i = 0; i < lines.length; i++)
		result += "\t\t\t" + lines[i] + "\n";
	result += endComment + "\n";
	result += end;

	return result;
}

function initHeader(dataWidth)
{
	let header = "";

	header += "function()\n";
	header += "{\n";
	header += "\tlet result = create2DArray(this.rows,this.cols);\n\n";

	header += "\tfor(let r = 0; r < this.rows; r++)\n";
	header += "\t{\n";
	header += "\t\tfor(let c = 0; c < this.cols; c++)\n";
	header += "\t\t{\n";
	header += "\t\t\tlet curr = new Cell(this," + parseInt(dataWidth) + ",r,c);\n";

	return header;
}

function initEnder()
{
	let ender = "";

	ender += "\t\t\tresult[r][c] = curr;\n";
	ender += "\t\t}\n";
	ender += "\t}\n\n";
	ender += "\tthis.grid = result;\n";
	ender += "}\n";

	return ender;
}

// DEBUGGING STUFF
//----------------------------------------------------------------------------------------------

// How do you even test this? Here's a sample:
// debugInitialization("{[0],[0],[1],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[1],[0],[0],[0],[0],[0],[0]},{[1],[1],[1],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]},{[0],[0],[0],[0],[0],[0],[0],[0],[0],[0]}");
// all one line of code that you can input into the console
function debugInitialization(rawData)
{
	let grid = parseInitialization(rawData);

	for(let r = 0; r < grid.length; r++)
	{
		console.log("ROW " + r);
		for(let c = 0; c < grid.length; c++)
		{
			console.log("\tCOL " + c);
			let cell = grid[r][c];

			for(let k = 0; k < cell.state.length; k++)
			{
				console.log("\t\tSTATE " + k + ": " + cell.state[k]);
			}
		}
	}
}